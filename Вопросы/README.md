### 1. Какой самый эффективный способ конкатенации строк?
Т.к. строки у нас immutable, при их складывании выделяется новый участок памяти, что не выгодно при сложении большого к-ва строк.
Лучше всего складывать строки через strings.Builder(), и затем уже с помощью метода WriteString(str string) складывать строки.
Чтобы получить итоговую строку, нужно вызвать метод String().
### 2. Что такое интерфейсы, как они применяются в Go?
Интерфейсы это некий контракт между структурой(классом). В таких языках как java, c++, c# используется явное подключение интерфейса к структуре. В Golang явного указания, что структура является частью множества объектов одного интерфейса - нет. Тут работает утиная типизация. "Если что-то крякает, то это утка". Если какая-то структура определила методы, которые есть в интерфейсе, то она автоматически является частью этого типа множества.
### 3. Чем отличаются RWMutex от Mutex?
У обычного mutex есть только метод Lock и Unlock для блокировки/разблокировки. У RWMutex(Read Write Mutex) есть два типа блокировки. 1) Блокировка на чтение 2) Блокировка на запись. RWMutex используется, когда нужно конкурентно иметь доступ к записи и получению элемнтов.
Когда срабатывает Lock(блокировка на запись), блокируются все участки когда с RLock и Lock, и может выполняться только одна блокировка на запись. Когда срабатывает RLock, не сработает блокировка на запись, однако она не заблочит другие RLock, что повышает производительность, чем использование обычного Mutex.
### 4. Чем отличаются буферизированные и не буферизированные каналы?
Буферизированные каналы будут блочиться только тогда, когда к-во записанных данных в канале полностью заполнит буфер. Не буферизированный канал же будет блочиться каждый раз о запись, пока его содержимое не прочитают. 
### 5. Какой размер у структуры struct{}{}?
Пустая структура имеет наименьшее потребление памяти, и занимает 0 байт. Однако все же происходит потребление памяти в объявлении, хранении указателя.
### 6. Есть ли в Go перегрузка методов или операторов?
Нет. В Golang нет перегрузки методов и операторов. Предлагается использовать просто разные имена функций. Иногда перегрузка методов может путать разработчиков, да и требуется дополнительная проверка на типы данных, чтобы вызвать нужную функцию.
### 7. В какой последовательности будут выведены элементы map[int]int?
Пример: 
```go
m[0]=1
m[1]=124
m[2]=281
```
Мапа это неупорядоченная структура данных, и не гарантирует хранение данных в том порядке в которым мы записали. Однако Println у себя сортирует мапу по ключам, а значит вывод будет следующим.
```bash
map[0:1 1:124 2:281]
```
### 8. В чем разница make и new?
make позволяет проинициализировать слайсы, мапы, каналы. new же позволяет выбрать явно адрес переменной и вернуть указатель на нужный нам участок памяти.
### 9. Сколько существует способов задать переменную типа slice или map?
```go
slice := []int{} // с cap = 0 и len = 0
slice = make([]int, 10, 100) // cap = 100, len = 10
var slice []int // с cap = 0 и len = 0
// так же можно создать слайс на основе массива
arr := [5]int{1,2,3,4,5}
slice = arr[1:4]

mapa := map[int]int{} //пустая мапа len = 0
mapa = make(map[int]int) //пустая мапа
mapa = make(map[int]int, 100) //пустая мапа, с капасити 100
var mapa map[int]int //nil
```
### 10. Что выведет данная программа и почему?
```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
Код выведет следующее
```bash
1
1
```
Это происходит из-за того что в go все передается по значению. В нашем случае мы передаем копию указателя p, и изменяем его в функции update на &b, что перезаписывает нашу копию, но не изменяет p в методе main().
Чтобы изменить вывод программы, вместо строчки p = &b, нужно написать *p = b. Так мы разыменовываем указатель и получает доступ к переменной a. Вывод после этого будет следующий.
```bash
1
2
```
### 11. Что выведет данная программа и почему?
```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
Deadlock, в самой документации сказано, что "A WaitGroup must not be copied after first use.". Копируя Mutex, мы копируем и его state, а уменьшая state у копии - не уменьшаем у оригинала. Из-за этого происходит deadlock.
### 12. Что выведет данная программа и почему?
```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
Выведет следующее: 
```bash
0
```
Чтобы в этом разобраться нужно знать о области видимости переменных. В области if мы определяем новую переменную n, перекрывая область видимости main функции, и изменяем только новую n в блоке if.
### 13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
Выведет следующее:
```bash
100, 2, 3, 4, 5
```
Тут опять же стоит вспомнить то, что в go все передается по значению. У слайса(как структуры) есть такие поля, указатель как массив, длинна слайса(к-во елементов в слайсе), капасити(длинна внутреннего массива). И передавая его в метод все его поля копируются, а изменяя копию мы не меняем оригинал. Однако в строке v[0] = 100, мы меняем не копию массива, а копию указателя на массив, что позволило нам изменить первый элемент.
### 14. Что выведет данная программа и почему?
```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
Выведет следующее:
```bash
[b, b, a][a, a]
```
Так как мы опять передаем копию, мы не изменяем оригинальный слайс.

Обратимся к первой строчке. slice := []string{"a", "a"} тут мы создаем слайс [a, a] с длинной 2 и капасити 2.
Далее передаем его в функцию. В строке функции slice = append(slice, "a"), из-за превышения капасити, создается копия массива с увеличинным капасити(меняется указатель на массив в копии). slice[0] = "b" slice[1] = "b" изменяют элементы уже нового массива, затем выводится [b, b, a] а после функции - неизмененная [a, a]
